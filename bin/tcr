#!/bin/bash

# This script watches for file changes (via fswatch) in your git repository,
# runs your configured test command(s), and commits if they pass, reverts if
# they fail.
#
# This is Kent Beck's TCR idea:
# - test && commit || revert - Kent Beck - Medium
#   https://medium.com/@kentbeck_7670/test-commit-revert-870bbd756864
# - TCR test && commit || revert -- Rope in Python
#   https://www.youtube.com/playlist?list=PLlmVY7qtgT_nhLyIbeAaUlFOWbWT5y53t
#
# I'm interested in TCR as a forcing function for:
# 1. Keeping me focused, rather than rambling about in the code
# 2. Keeping me oriented toward refactoring as the language of change
# 3. Keeping the tests really really fast

set -euo pipefail

# Let's clear the screen before we get started.
tput reset

# Now, TCR makes a lot (a LOT!) of small commits with meaningless messages.
# Maybe we don't worry about them! See Limbo: https://medium.com/@kentbeck_7670/limbo-on-the-cheap-e4cfae840330
# But for me, for now, on my projects, I'd like to squash a session's work into one commit.
# There's git tooling to help: `git commit --fixup` and `git rebase --interactive --autosquash`.
# So we start by making an empty base commit (with a fun message!) here before we enter the TCR loop.
# (Perhaps we should just run `git commit --amend` instead, avoiding the rebase altogether.
#  But something about retaining short-term access to the commit history feels comforting to me.
#  I'll keep an eye on this as I continue to work.)
emoji=("🍻" "🦖" "🌯" "🍕" "🎸" "🚀" "🦏" "🍩" "🍦")
random_emoji=${emoji[$RANDOM % ${#emoji[@]} ]}
git commit --message "$random_emoji $(date '+%A, %B %e')" --allow-empty
base=$(git rev-parse HEAD)

test_and_commit_or_revert() {
  local base=${1}

  # A cyan heading and a little whitespace help me scan the output.
  run() {
    echo "$(tput setaf 6)$*$(tput sgr0)"
    eval $*
    echo
  }

  # Clear the screen at the beginning of each run.
  tput reset

  # When the code gets reverted, it's helpful to see what we did wrong.
  run git --no-pager diff

  # We use a subshell with `set -e` to bail as soon as a test command fails,
  # so we don't have to copy around exit codes manually.
  ( set -e

    # But how to restore the lovely balancing newline (from `run`) then?
    # Like this. So cool:
    set -E
    trap echo ERR

    # Where to store the project-specific test commands?
    # Scripts or config files are messy -- and we're already using git!
    # So put it in a multi-valued git config key:
    # `git config --add tcr.command "/path/to/thing --with --some args"
    while read -r command; do
      run $command
    done < <(git config --get-all tcr.command)
  )

  result=$?

  if [ $result -eq 0 ]; then
    run git commit --all --fixup $base --allow-empty
  else
    run git reset --hard
  fi
}

# See below. We're going to run this function in a new shell, so we need to export it.
export -f test_and_commit_or_revert

# Why not just use fswatch's own looping?
# Because the revert would otherwise trigger another burst of fswatch events,
# but we want to leave the bad diff and the test failures on the screen.
running=1; trap "running=0" INT

while [ $running -eq 1 ]; do
  # You can get fswatch via `brew install fswatch`
  # http://emcrisostomo.github.io/fswatch/getting.html
  # Piping to xargs (rather than using && or ;) keeps us from running tests on ctrl-c.
  fswatch --one-event --latency 0.1 $(git ls-files) \
    | xargs bash -c "test_and_commit_or_revert $base"
done
