#!/usr/bin/ruby -wKU

require 'rubygems'
require 'appscript'

class Event < Struct.new(:event)
  # Event's class methods handle retrieving Event instances from iCal.
  class << self
    def occurring(time_range)
      find(within(time_range))
    end

    private

    def find(conditions)
      if ical.is_running?
        ical.calendars.events[conditions].get.flatten.map { |event| Event.new(event) }
      else
        ["Please launch iCal to retrieve events."]
      end
    end

    def ical
      Appscript.app('iCal.app')
    end

    def within(range)
      starts_before(range.last).and(ends_after(range.first))
    end

    def starts_before(cutoff)
      Appscript.its.start_date.lt(cutoff)
    end

    def ends_after(cutoff)
      Appscript.its.end_date.gt(cutoff)
    end
  end

  # Event instances wrap AppleScript "Events" from iCal, making them sortable
  # and giving them a nice String representation.
  include Comparable

  def <=>(other)
    self.start_date <=> other.start_date
  end

  def to_s
    "#{time_prefix}#{summary}#{location_suffix}"
  end

  private

  # delegate attribute lookup to the wrapped AppleScript "Event".
  def method_missing(name, *args)
    if event.respond_to?(name)
      event.send(name, *args).get
    else
      super
    end
  end

  def time_prefix
    if allday_event
      ''
    else
      "#{start_date.in_short_time_format} - "
    end
  end

  def location_suffix
    if location == :missing_value
      ''
    else
      " at #{location}"
    end
  end
end

# Extend Date to make it easy to say Time.tomorrow.
class Date
  def self.tomorrow
    today.succ
  end

  def to_time
    Time.local(year, month, day)
  end
end

# Extend Time, since Time.tomorrow looks nice when paired with Time.now. Also
# give a nice String representation of Time.
class Time
  def self.tomorrow
    Date.tomorrow.to_time
  end

  def in_short_time_format
    strftime('%l:%M%p').downcase
  end
end

# And here's what we actually do:
puts Event.occurring(Time.now..Time.tomorrow).sort

