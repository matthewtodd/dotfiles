#!/usr/bin/ruby -wKU

require 'rubygems'
require 'appscript'

class Event < Struct.new(:event)
  # Event's class methods handle retrieving Event instances from iCal.
  class << self
    include Appscript

    def occurring(time_range)
      find(within(time_range))
    end

    private

    def find(conditions)
      if ical.is_running?
        ical.calendars.events[conditions].get.flatten.map { |event| Event.new(event) }
      else
        ["Please launch iCal to retrieve events."]
      end
    end

    def ical
      app('iCal.app')
    end

    def within(range)
      all_of its.start_date.lt(range.last),
             its.end_date.gt(range.first)
    end

    def all_of(*conditions)
      conditions.inject { |composite, condition| composite.and(condition) }
    end
  end

  # Event instances wrap AppleScript "Events" from iCal, making them sortable
  # and giving them a nice String representation.
  include Comparable

  def <=>(other)
    self.start_date <=> other.start_date
  end

  def to_s
    if allday_event
      summary
    else
      "#{start_date.in_short_time_format} - #{summary}"
    end
  end

  private

  def method_missing(name, *args)
    if event.respond_to?(name)
      event.send(name, *args).get
    else
      super
    end
  end
end

# Extend Date to make it easy to say Time.tomorrow.
class Date
  def self.tomorrow
    today.succ
  end

  def to_time
    Time.local(year, month, day)
  end
end

# Extend Time, since Time.tomorrow looks nice when paired with Time.now. Also
# give a nice String representation of Time.
class Time
  def self.tomorrow
    Date.tomorrow.to_time
  end

  def in_short_time_format
    strftime('%l:%M%p').downcase
  end
end

# And here's what we actually do:
puts Event.occurring(Time.now..Time.tomorrow).sort

