#!/usr/bin/env ruby

require 'rubygems'
require 'net/ssh'
require 'pathname'
require 'readline'
require 'shellwords'

class Downloads
  class << self
    def run(args)
      application = new
      command     = args.shift || 'shell'

      if application.respond_to?(command)
        application.send(command)
      else
        abort 'Say what?'
      end
    end
  end

  attr_reader :remote_host
  attr_reader :remote_path
  attr_reader :local_path
  attr_reader :uris
  attr_reader :config_path
  attr_reader :pid_path
  attr_reader :partial_path

  def initialize
    @remote_host  = 'woodward'
    @remote_path  = 'downloads/'
    @local_path   = '/Users/matthew/Downloads/'
    @uris         = []
    @config_path  = Pathname.new(ENV['HOME']).join('.downloads')
    @pid_path     = config_path.join('pid')
    @partial_path = "#{config_path}/partial/" # the trailing slash is vital. rsync.
  end

  def list
    name_width = remote_files.keys.map { |name| name.length }.max

    remote_files.sort.map do |name, size|
      puts format_status(name, size, :name_width => name_width)
    end
  end
  alias_method :ls, :list

  def refresh
    puts 'Clearing cache.'
    local_files(0)
    remote_files(0)
    list
  end

  def shell
    loop do
      case line = prompt('> ', 'quit')
      when ''
        next
      when 'exit', 'quit'
        puts
        break
      when /^http/
        enqueue(URI.parse(line))
      else
        puts 'Type exit, or enter a URI to download.'
      end
    end

    unless uris.empty?
      begin
        exec_commands(uris.map { |uri| download_command(uri) })
      rescue Interrupt
        puts
        shell
      rescue SocketError => e
        puts e.message
        shell
      end
    end

    puts 'Goodbye.'
  end

  def start
    stop

    pid_path.open('w') do |file|
      file.write(Process.pid)
    end

    remote_files(0).sort_by { |_, size| size }.each do |name, _|
      child = fork do
        exec "ssh-agent rsync --progress --partial-dir=#{partial_path} --remove-source-files #{remote_host}:#{remote_path}#{name} #{local_path}"
      end

      %w(INT TERM).each do |signal|
        Signal.trap(signal) do
          Process.kill(signal, child)
          exit
        end
      end

      Process.wait
    end
  end

  def stop
    if File.exists?(pid_path)
      `kill #{pid_path.read}`
    end
  end

  private

  def cache(filename, ttl)
    path = config_path.join(filename)

    def path.refresh(ttl)
      if exist?
        yield self if (Time.now - mtime) > ttl
      else
        FileUtils.touch(to_s)
        yield self
      end
    end

    path.refresh(ttl) do |file|
      content = yield

      unless content.nil?
        file.open('w') do |stream|
          stream.write(content)
        end
      end
    end

    path.read
  end

  def download_command(uri)
    "curl --location --output #{remote_path}#{Shellwords.escape(uri[:filename])} #{Shellwords.escape(uri[:uri].to_s)}"
  end

  def enqueue(uri)
    default_filename = uri.path.split('/').last || 'index.html'

    filename = case line = prompt("#{default_filename} ? ", default_filename, false)
               when ''
                 default_filename
               else
                 line
               end

    uris.push(:uri => uri, :filename => filename)
  end

  def exec_commands(commands)
    puts 'Connecting to server.'

    Net::SSH.start(remote_host, nil) do |ssh|
      commands.each do |command|
        puts command
        ssh.exec!(command) do |ch, stream, data|
          case stream
          when :stdout
            $stdout.write(data)
            $stdout.flush
          when :stderr
            $stderr.write(data)
            $stderr.flush
          end
        end
      end

      puts 'Updating local cache.'

      cache('remote_files', 0) do
        ssh.exec!(ls_command(remote_path))
      end
    end
  end

  def files(directory, tag, ttl)
    listing = cache(tag, ttl) do
      run(ls_command(directory))
    end

    files = {}

    listing.each_line do |line|
      mode, size, day, time, name = line.strip.split(/\s+/, 5)
      files[name] = size.to_i unless name == '.'
    end

    files
  end

  def format_bytes(bytes)
    case bytes
    when (0...1024)
      "#{bytes}B"
    when (1024...1024**2)
      "#{bytes/1024}K"
    when (1024**2...1024**3)
      "#{bytes/1024**2}M"
    else
      "#{bytes/1024**3}G"
    end
  end

  def format_percentage(numerator, denominator)
    value = if denominator == 0
              '-'
            else
              (numerator.to_f * 100 / denominator).to_i
            end

    "#{value}%"
  end

  def format_status(name, size, options={})
    columns = []

    columns << name.ljust(options[:name_width] || 0)
    columns << format_percentage(local_files[name], size).rjust(4)
    columns << format_bytes(size)

    columns.join("\t")
  end

  def local_files(ttl=0)
    @local_files ||= files(local_path, 'local_files', ttl).merge(files(partial_path, 'partial_local_files', ttl))
  end

  def ls_command(directory)
    "rsync --list-only #{directory}"
  end

  def prompt(prompt, default, exit_completely_on_interrupt = true)
    line = begin
             Readline::readline(prompt) || default
           rescue Interrupt
             puts 'Abort.'
             if exit_completely_on_interrupt
               exit
             else
               return
             end
           end

    line.strip
  end

  def remote_files(ttl=3600)
    @remote_files ||= files("#{remote_host}:#{remote_path}", 'remote_files', ttl)
  end

  def run(command)
    output = `#{command}`

    if $?.exitstatus == 0
      output
    else
      nil
    end
  end
end

if $0 == __FILE__
  Downloads.run(ARGV.dup)
end
