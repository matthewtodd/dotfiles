#!/usr/bin/ruby -swU

require 'minitest'
require 'timeout'
require 'tmpdir'

# For file watching, I could shell out to something like [fswatch][] or
# [entr][], or I could do something in pure Ruby, as in [filewatcher][].
# There's also the chance to maybe drop down to C and use Apple's [File System
# Events API][].
#
# I wonder if it might be enough to watch directories. Do their mtimes change
# when the files they contain do? That's something I can easily test.
#
# [fswatch]: https://emcrisostomo.github.io/fswatch/
# [entr]: https://eradman.com/entrproject/
# [filewatcher]: https://github.com/filewatcher/filewatcher
# [File System Events API]: https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005289
#
# I also see that I can make (non-portable) syscalls from Ruby (with
# Kernel#syscall), and that there are kqueue and kevent syscalls that I think
# I've heard about having been used for file watching.
#
# I'm looking at multiple event triggers, so it feels like either select or
# Go's waiting for multiple channels thing. I wonder how I could do that here.
# Maybe with something that looks like an event loop, checking all the inboxes?
# Or could I do something gross like signalling myself? Or maybe what this
# looks like is lots of actors writing to a Queue, with the main process
# blocking reading on it. That would mean no pre-empting?
#
# I'm noticing a Stopper type to handle ctrl-c. Maybe there are lots of things
# in this queue soup? Or maybe it's just keyboard and filesystem. Does this
# become event sourcing??
#
# At this point there might be some benefit to writing this code in a different
# language. It might be that Go has something to offer, and it would give me
# practice writing a small standalone Go application. But I think I want to
# stay in fun, irresponsible space for now, and Go starts to feel too much like
# responsible learning.

class Application
  def run
    puts "--> foo"
    while true do
    end
  end
end

class ApplicationTest < Minitest::Test
  TCR = File.expand_path(__FILE__)

  def test_application
    Dir.mktmpdir do |pwd|
      Dir.chdir(pwd) do
        system "git init", out: "/dev/null"
        system "git commit -m 'Initial commit.' --allow-empty", out: "/dev/null"
        system "git config tcr.command /bin/true", out: "/dev/null"

        tcr = Driver.new self, IO.popen(TCR, err: :out)
        tcr.assert_screen("--> foo\n")
      end
    end
  end

  class Driver
    include Timeout

    def initialize(test, io)
      @test = test
      @io = io
      at_exit { Process.kill("TERM", @io.pid) }
    end

    def assert_screen(expected)
      actual = timeout(1) { @io.readpartial(4096) } # Drain whatever initial output there was.
      @test.assert_equal expected, actual
    end
  end
end

class Colorized
  def initialize
    @passed = true
    @failures = []
  end

  def start
  end

  def record(result)
    print colorized(result.result_code)

    unless result.passed?
      @passed = false
      @failures << result
    end
  end

  def report
    puts
    puts @failures
  end

  def passed?
    @passed
  end

  private

  COLORS = {
    "." => "32",
    "F" => "31;1",
    "E" => "33;1",
    "S" => "36",
  }.freeze

  def colorized(result_code)
    "\e[#{COLORS.fetch(result_code)}m#{result_code}\e[0m"
  end
end

Minitest.extensions << :colorized

def Minitest.plugin_colorized_init(options)
  reporter.reporters = [Colorized.new]
end

# The -s switch in our shebang line captures command-line flags as global
# variables, so we can run `tcr -t` for self testing.
if global_variables.include? :$t
  Minitest.autorun
elsif __FILE__ == $0
  $stdout.sync = true
  Application.new.run
end
