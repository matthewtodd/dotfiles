#!/usr/bin/ruby -wU --disable-all

require 'timeout'
require 'tmpdir'

# For file watching, I could shell out to something like [fswatch][] or
# [entr][], or I could do something in pure Ruby, as in [filewatcher][].
# There's also the chance to maybe drop down to C and use Apple's [File System
# Events API][].
#
# I wonder if it might be enough to watch directories. Do their mtimes change
# when the files they contain do? That's something I can easily test.
#
# [fswatch]: https://emcrisostomo.github.io/fswatch/
# [entr]: https://eradman.com/entrproject/
# [filewatcher]: https://github.com/filewatcher/filewatcher
# [File System Events API]: https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005289
#
# I'm looking at multiple event triggers, so it feels like either select or
# Go's waiting for multiple channels thing. I wonder how I could do that here.
# Maybe with something that looks like an event loop, checking all the inboxes?
# Or could I do something gross like signalling myself? Or maybe what this
# looks like is lots of actors writing to a Queue, with the main process
# blocking reading on it. That would mean no pre-empting?
#
# I'm noticing a Stopper type to handle ctrl-c. Maybe there are lots of things
# in this queue soup? Or maybe it's just keyboard and filesystem. Does this
# become event sourcing??
#
# At this point there might be some benefit to writing this code in a different
# language. It might be that Go has something to offer, and it would give me
# practice writing a small standalone Go application. But I think I want to
# stay in fun, irresponsible space for now, and Go starts to feel too much like
# responsible learning.

if Kernel.const_defined? :Minitest
  Test = Minitest::Test
else
  Test = Object
end

class ApplicationTest < Test
  TCR = File.expand_path(__FILE__)

  def test_application
    Dir.mktmpdir do |pwd|
      Dir.chdir(pwd) do
        system "git init"
        system "git commit -m 'Initial commit.' --allow-empty"
        system "git config tcr.command /bin/true"

        begin
          tcr = Driver.new IO.popen(TCR)
          tcr.assert_screen
        ensure
          tcr.terminate
        end
      end
    end
  end

  class Driver
    include Timeout

    def initialize(io)
      @io = io
    end

    def assert_screen
      timeout(1) { @io.readpartial(4096) } # Drain whatever initial output there was.
    end

    def terminate
      Process.kill("TERM", @io.pid)
    end
  end
end

if Kernel.const_defined? :Minitest
  # Maybe set up a custom reporter?
elsif __FILE__ == $0
  $stdout.sync = true
  puts "--> foo"
  while true do
  end
end
